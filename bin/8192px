#!/usr/bin/env node

var fs = require('fs');
var http = require('http');
var mime = require('mime');
var path = require('path');
var url = require('url');
var ws = require('ws');

const IMG_PATH = 'bin/canvas.png';

const Canvas = require('./Canvas');
const {
	getColorId,
	colors,
	OPCODES,
	compress,
	decompress
} = require('./utils');

// function is just for awaits
async function start() {
	let canvas = new Canvas();
	await canvas.load(fs.existsSync(IMG_PATH) ? IMG_PATH : null);

	setInterval(function () {
		let {
			heapTotal,
			heapUsed
		} = process.memoryUsage();
		console.log(`Memory total: ${heapTotal/10000000}MB. Memory used: ${heapUsed/10000000}MB.`);
		console.log(`Canvas size: ${canvas.width}x${canvas.height}`);
		console.log('-------------------------')
	}, 10000)

	var server = http.createServer();
	server.on('request', function (request, response) {
		var uri = url.parse(request.url);
		var pathname = uri.pathname;
		if (pathname == '/') {
			pathname = '/index.html';
		}

		var filepath = path.join('public', pathname);
		fs.stat(filepath, function (error, stat) {
			if (error) {
				response.writeHead(404, {
					'Content-Type': 'text/plain',
				});

				return response.end('404: Not Found');
			}

			response.writeHead(200, {
				'Content-Type': mime.lookup(filepath),
				'Content-Length': stat.size,
				'Etag': [stat.ino, stat.size, JSON.stringify(stat.mtime)].join('-') + '"',
				'Last-Modified': stat.mtime,
			});

			var input = fs.createReadStream(filepath);
			input.pipe(response);
		});
	});

	var sessions = {};
	var connections = [];
	var socket = ws.createServer({
		server: server
	});
	socket.on('connection', function (connection) {
		var id = connection.upgradeReq.headers['x-forwarded-for'];
		if (id == null) {
			id = connection.upgradeReq.socket.remoteAddress;
		}
		console.log(id)

		connection.id = id;
		connection.session = (sessions[id] = sessions[id] || {
			wait: 0,
		});

		if (connection.session.wait > Date.now()) {
			try {
				let dv = new DataView(1 + 8);
				dv.setUint8(OPCODES.COOLDOWN);
				dv.setFloat64(connection.session.wait);

				connection.send(dv);
			} catch (error) {
				console.error(error);
			}
		}

		connections.push(connection);
		connection.on('message', function (data, flags) {
			if (flags.binary) {
				let dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
				switch (dv.getUint8(0)) {
					case OPCODES.PIXEL: {
						if (connection.session.wait > Date.now()) return

						let x = dv.getUint16(1);
						let y = dv.getUint16(3);

						if (x >= canvas.width || y >= canvas.height || x < 0 || y < 0) {
							return;
						}

						const colorId = dv.getUint8(5);
						if (colorId < 0 || colorId >= colors.length) return;

						canvas.setPixel(x, y, colorId);

						connections.forEach(function (connection) {
							try {
								connection.send(data);
							} catch (error) {
								console.error(error);
							}
						});

						var factor = Math.sin((x * 0.5) + (y * 0.5));
						var duration = Math.abs(factor) * 8192 * Math.min(100, connections.length / 100);

						if (id === '::1') {
							connection.session.wait = 0;
						} else {
							connection.session.wait = Date.now() + Math.max(1000, Math.floor(duration));
						}

						dv = new DataView(new ArrayBuffer(1 + 8));
						dv.setUint8(0, OPCODES.COOLDOWN);
						dv.setFloat64(1, connection.session.wait);

						connection.send(dv.buffer);
						break
					}
				}
			}
		});

		connection.on('close', function () {
			connections.splice(connections.indexOf(connection), 1);
		});

		let pixelData = canvas.data; //canvas.toBuffer();
		let compressed = compress(pixelData);
		const badCompression = (compressed.length > pixelData.length);
		let data
		if (badCompression) {
			data = new Uint8Array(pixelData.length + 10);
		} else {
			data = new Int8Array(compressed.length + 10);
		}

		let view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		view.setUint8(0, OPCODES.BOARD);
		view.setUint8(1, badCompression ? 0 : 1);

		view.setUint16(2, 0);
		view.setUint16(4, 0);
		view.setUint16(6, canvas.width);
		view.setUint16(8, canvas.height);

		data.set(badCompression ? pixelData : compressed, 10);

		try {
			connection.send(data);
		} catch (error) {
			console.error(error);
		}
	});

	setTimeout(function callback(then, cooldown, delay) {
		var now = Date.now();
		var time = now - then;

		if (connections.length > 0) {
			cooldown -= time;
		}

		if (cooldown <= 0) {
			cooldown = cooldown + delay;

			var count = 8;
			canvas.expand(count);
			let pixelData = canvas.data; //canvas.toBuffer();
			let compressed = compress(pixelData);
			console.log(pixelData.length, decompress(compressed).length)
			fs.writeFileSync('test', [...pixelData, '\n', ...compressed].join(','))
			const badCompression = (compressed.length > pixelData.length);
			let data
			if (badCompression) {
				data = new Uint8Array(pixelData.length + 10);
			} else {
				data = new Int8Array(compressed.length + 10);
			}

			let view = new DataView(data.buffer, data.byteOffset, data.byteLength);

			view.setUint8(0, OPCODES.BOARD);
			view.setUint8(1, badCompression ? 0 : 1);

			view.setUint16(2, 0);
			view.setUint16(4, 0);
			view.setUint16(6, canvas.width);
			view.setUint16(8, canvas.height);

			data.set(badCompression ? pixelData : compressed, 10);


			connections.forEach(function (connection) {
				try {
					connection.send(data);
				} catch (error) {
					console.error(error);
				}
			});
		}

		canvas.save(IMG_PATH).then(function () {
			setTimeout(callback, 20000, now, cooldown, delay);
		})
	}, 0, Date.now(), 20000, 20000);

	server.listen(process.env['PORT'] || 8192);
}
start();