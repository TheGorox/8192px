#!/usr/bin/env node

var fs = require('fs');
var http = require('http');
var mime = require('mime');
var path = require('path');
var url = require('url');
var ws = require('ws');

const IMG_PATH = 'bin/canvas.png'; 

const Canvas = require('./Canvas');
const {
	getColorId,
	colors
} = require('./utils');

// function is just for awaits
async function start() {
	let canvas = new Canvas();
	await canvas.load(fs.existsSync(IMG_PATH) ? IMG_PATH : null);

	setInterval(function(){
		let {
			heapTotal,
			heapUsed
		} = process.memoryUsage();
		console.log(`Memory total: ${heapTotal/10000000}MB. Memory used: ${heapUsed/10000000}MB.`);
		console.log(`Canvas size: ${canvas.width}x${canvas.height}`);
		console.log('-------------------------')
	}, 10000)

	var server = http.createServer();
	server.on('request', function (request, response) {
		var uri = url.parse(request.url);
		var pathname = uri.pathname;
		if (pathname == '/') {
			pathname = '/index.html';
		}
		
		var filepath = path.join('public', pathname);
		fs.stat(filepath, function (error, stat) {
			if (error) {
				response.writeHead(404, {
					'Content-Type': 'text/plain',
				});
				
				return response.end('404: Not Found');
			}
			
			response.writeHead(200, {
				'Content-Type': mime.lookup(filepath),
				'Content-Length': stat.size,
				'Etag': [stat.ino, stat.size, JSON.stringify(stat.mtime)].join('-') + '"',
				'Last-Modified': stat.mtime,
			});
			
			var input = fs.createReadStream(filepath);
			input.pipe(response);
		});
	});
	
	var sessions = {};
	var connections = [];
	var socket = ws.createServer({
		server: server
	});
	socket.on('connection', function (connection) {
		var id = connection.upgradeReq.headers['x-forwarded-for'];
		if (id == null) {
			id = connection.upgradeReq.socket.remoteAddress;
		}
		console.log(id)
		
		connection.id = id;
		connection.session = (sessions[id] = sessions[id] || {
			wait: 0,
		});
		
		if (connection.session.wait > Date.now()) {
			try {
				connection.send(Uint32Array.of(connection.session.wait))
			} catch (error) {
				console.error(error);
			}
		}
		
		connections.push(connection);
		connection.on('message', function (data, flags) {
			if (flags.binary) {
				if (connection.session.wait > Date.now()) {
					connection.send(Float64Array.of(connection.session.wait));
				} else {
					var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
					
					var width = view.getUint16(4);
					var height = view.getUint16(6);
					
					if (width != 1 || height != 1) {
						return;
					}
					
					var x = view.getUint16(0);
					var y = view.getUint16(2);
					
					if (x > canvas.width || y > canvas.height || x < 0 || y < 0) {
						return;
					}
					
					const colorId = getColorId([view.getUint8(8), view.getUint8(9), view.getUint8(10)])
					
					if (colorId != -1) {
						canvas.setPixel(x, y, colorId);
						
						connections.forEach(function (connection) {
							try {
								connection.send(data);
							} catch (error) {
								console.error(error);
							}
						});
					}
					
					var factor = Math.sin((x * 0.5) + (y * 0.5));
					var duration = Math.abs(factor) * 8192 * Math.min(100, connections.length / 100);
					
					if(id === '::1'){
						connection.session.wait = 0;
					}else{
						Date.now() + Math.max(1000, Math.floor(duration));
					}
					connection.send(Float64Array.of(connection.session.wait));
				};
			}
		});
		
		connection.on('close', function () {
			connections.splice(connections.indexOf(connection), 1);
		});
		
		let pixelData = canvas.toBuffer();
		var data = new Uint8Array(8 + pixelData.length);
		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
		
		view.setUint16(0, 0);
		view.setUint16(2, 0);
		view.setUint16(4, canvas.width);
		view.setUint16(6, canvas.height);
		
		data.set(pixelData, 8);
		
		try {
			connection.send(data);
		} catch (error) {
			console.error(error);
		}
	});
	
	setTimeout(function callback(then, cooldown, delay) {
		var now = Date.now();
		var time = now - then;
		
		if (connections.length > 0) {
			cooldown -= time;
		}
		
		if (cooldown <= 0) {
			cooldown = cooldown + delay;
			
			var count = 8;
			canvas.expand(count);
			let pixelData = canvas.toBuffer();
			
			var data = new Uint8Array(pixelData.length + 8);
			var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
			
			view.setUint16(0, 0);
			view.setUint16(2, 0);
			view.setUint16(4, canvas.width);
			view.setUint16(6, canvas.height);
			
			data.set(pixelData, 8);
			
			connections.forEach(function (connection) {
				try {
					connection.send(data);
				} catch (error) {
					console.error(error);
				}
			});
		}
		
		canvas.save(IMG_PATH).then(function () {
			setTimeout(callback, 10000, now, cooldown, delay);
		})
	}, 0, Date.now(), 10000, 10000);
	
	server.listen(process.env['PORT'] || 8192);
}
start();